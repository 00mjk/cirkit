\let\safetikz\shipout
\input pgf
\input tikz
\usetikzlibrary{calc,matrix}
\tikzset{>=stealth}
\let\shipout\safetikz

\magnification\magstephalf
\parskip3pt
\baselineskip14pt

\catcode`@=11
\def\oldstyle{\fam\@ne\teni}

\def\bbbb{{\rm I\!B}}

\def\slug{\hbox{\kern1.5pt\vrule width2.5pt height6pt depth1.5pt\kern1.5pt}}
\def\slugonright{\vrule width0pt\nobreak\hfill\slug}

% Equations
\def\eqex{1}
\def\eqmap{2}
\def\eqexva{3}
\def\eqfuncsem{4}
\def\eqonehota{5}
\def\eqonehotb{6}
\def\eqinjsem{7}
\def\eqonehotc{8}
\def\eqhvar{9}
\def\eqhmatrix{10}
\def\eqhjl{11}
\def\eqttrue{12}
\def\eqtfalse{13}
\def\eqhclause{14}

\centerline{\bf Reverse engineering using simulation graphs and bipartite subgraph isomorphism}
\centerline{Mathias Soeken, University of Bremen}
\centerline{Bremen, September 4, 2014}
\bigskip\bigskip

\noindent {\bf 1. Bipartite subgraph isomorphism.} We refer to a {\it
unidirected\/} bigraph as a digraph $G=(V,A)$ for which $V$ is a partition of
two disjoint sets of sources $V'$ and sinks $V''$ and arcs $A\subseteq V'\times
V''$, i.e.~the initial and final vertex of each arc lies in $V'$ and $V''$,
respectively.  The adjacency matrix of such a unidirected bigraph has always the
form $A=\big({O\atop O}{A'\atop O}\big)$ where each $O$ is a matrix containing
only zeros when the columns are arranged in a way that first vertices are taken
from $V'$ and then from $V''$.  Consequently, we can drop the $O$ matrices and
end up with the {\it compact\/} adjacency matrix~$A'$.  Given two unidirected
bigraphs called {\it target\/} $G=(V,A)$ and {\it pattern\/} $P=(W,B)$, the {\it
bipartite subgraph isomorphism\/} problem asks whether there exists a subgraph
$G'$ of $G$ such that~$G'$ is isomorphic to $P$, denoted $G'\cong P$.  In the
remainder, we will use the graphs
$$
  G=\quad
  \tikzpicture[baseline=(c.base),every node/.style={circle,draw,minimum size=.5cm,inner sep=1pt}]
    \node (v1) at (0,0) {$1$};
    \node (v2) at (0,-.75) {$2$};
    \node (v3) at (0,-1.5) {$3$};
    \node (v4) at (0,-2.25) {$4$};
    \node (w1) at ([xshift=1.5cm] $(v1)!.5!(v2)$) {$\bar 1$};
    \node (w2) at ([xshift=1.5cm] $(v2)!.5!(v3)$) {$\bar 2$};
    \node (w3) at ([xshift=1.5cm] $(v3)!.5!(v4)$) {$\bar 3$};

    \draw[->] (v1) to[bend left=10] (w1);
    \draw[->] (v1) -- (w2);
    \draw[->] (v2) -- (w1);
    \draw[->] (v2) -- (w3);
    \draw[->] (v3) -- (w2);
    \draw[->] (v4) to[bend left=10] (w1);
    \draw[->] (v4) to[bend right=10] (w2);
    \coordinate (c) at (current bounding box.west);
  \endtikzpicture
  \qquad\hbox{and}\qquad
  P=\quad
  \tikzpicture[baseline=(c.base),every node/.style={circle,draw,minimum size=.5cm,inner sep=1pt}]
    \node (v1) at (0,0) {$1$};
    \node (v2) at (0,-.75) {$2$};
    \node (v3) at (0,-1.5) {$3$};
    \node (w1) at ([xshift=1.5cm] $(v1)!.5!(v2)$) {$\bar 1$};
    \node (w2) at ([xshift=1.5cm] $(v2)!.5!(v3)$) {$\bar 2$};

    \draw[->] (v1) to[bend left=10] (w1);
    \draw[->] (v1) to[bend right=5] (w2);
    \draw[->] (v2) -- (w1);
    \draw[->] (v3) -- (w1);
    \draw[->] (v3) to[bend right=10] (w2);

    \coordinate (c) at (current bounding box.west);
  \endtikzpicture
  \eqno(\eqex)
$$
as target and pattern in a running example.  It can readily be verified, that
there exists a subgraph isomorphism between these two graphs.

\noindent {\bf SAT formulation.} We will now create a Boolean function $f$ that
is satisfiable if and only if $P$ is isomorphic to a subgraph of $G$.  In case
there exists such a subgraph it can be obtained from a satisfying assignment to
$f$.

First, we are looking to the bipartite subgraph isomorphism problem from a
different angle.  Let $g^{(1)},\dots,g^{(n)}$ and $p^{(1)},\dots,p^{(m)}$ be the
row vectors of the compact adjacency matrices of the target $G$ and pattern $P$.
Their bitwidths are $q$ and $r$, respectively.  Obviously, we have $m\le n$ and
$q\le r$.  The existence of a bipartite subgraph isomorphism is equivalent to
the existence of two injective functions $v:[m]\to[n]$ and $a:[r]\to[q]$ such
that
$$ p^{(j)}_l=g^{(v(j))}_{a(l)} \eqno(\eqmap) $$
for all $1\le j\le m$ and $1\le l\le r$.  (The notation $[n]$ is a shorthand for
the set $\{1,\dots,n\}$.)  The function $v$ maps each initial vertex in $P$ to a
distinct initial vertex in $G$, while the function $a$ maps each final vertex in
$P$ to a distinct final vertex in $G$.  For the example in (\eqex) we have
$$
  v(1)=4,\qquad v(2)=3,\qquad v(3)=1,\qquad
  a(\bar 1)=\bar 2,\qquad a(\bar 2)=\bar 1.
  \eqno(\eqexva)
$$
(The barred notation for values in $a$ has intetionally been used to improve
comprehensibility.)

This equivalent formulation makes it easy for us to describe the satisfiability
function $f$.  The function $v$ is described by $mn$ variables $v_{j,i}$ such
that $v(j)=i$ if and only if $v_{j,i}=1$ for all $1\le j\le m$ and $1\le i\le
n$; in other words we have $v_{j,v(j)}=1$.  To ensure function semantics,
i.e.~that each value $v(j)$ has exactly one value clauses for the Boolean
functions
$$ S_1(v_{j,1}, \dots, v_{j,n}) \qquad\hbox{for $1\le j\le m$} \eqno(\eqfuncsem) $$
are added.  ($S_1(x_1,\dots,x_n)$ describes the symmetric Boolean function that
are true if and only if exactly one of the $n$ variables is true; see
Eq.~7.1.1-({\oldstyle90}) in TAOCP.)  The encoding is sometimes referred to as
{\it one hot encoding\/} and can be enforced by the clauses
$$ v_{j,1}\lor\cdots\lor v_{j,n} \qquad \hbox{for $1\le j\le m$} \eqno(\eqonehota) $$
to ensure that at least one bit is set to 1 and by the exclusion clauses
$$ \bar v_{j,i}\lor \bar v_{j,i'} \qquad \hbox{for $1\le j\le m$ and $1\le i<i'\le n$}. \eqno(\eqonehotb) $$
The injectivity property can be enforced by adding clauses for the functions
$$ S_{\le1}(v_{1,i},\dots,v_{m,i}) \qquad\hbox{for $1\le i\le n$}. \eqno(\eqinjsem) $$
This ensures that for each $i\in\{1,\dots,n\}$ there is at most one $j$ such
that $v(j)=i$ and can be encoded using only the exclusion clauses
$$ \bar v_{j,i}\lor \bar v_{j',i} \qquad \hbox{for $1\le j<j'\le m$ and $1\le i\le n$}. \eqno(\eqonehotc) $$
Analogously, $rq$ variables $a_{l,k}$ describe function $a$ for $1\le j\le r$
and $1\le k\le q$ and similar clauses to (\eqonehota), (\eqonehotb), and
(\eqonehotc) ensure the correct semantics.

We are now getting to the core of (\eqmap).  We will eventually add clauses for
all function values of $v$ and $a$, i.e.~for all combinations of
$j\in\{1,\dots,m\}$ and $l\in\{1,\dots,r\}$ , but let us first take a look on
how to represent the right hand side in (\eqmap) using the variables we have
added so far.  For this purpose $nmqr$ variables $h_{i,j,k,l}$ are added for
which
$$h_{i,j,k,l} = g^{(i)}_k\land v_{j,i}\land a_{l,k} \eqno(\eqhvar)$$
should hold.  This will the most complicated variable in our encoding and it
requires some further discussion.  When we fix $j$ and $l$ and we range over all
$1\le i\le n$ and $1\le k\le q$ the values for $h_{i,j,k,l}$ are the components
of the result of the bitwise AND of the bitvectors $\hat g$, $\hat v$, and $\hat
a$:
$$
\tikzpicture[baseline=(c.base)]
  \matrix[matrix of math nodes] (m) {
  g^{(1)}_1 & g^{(1)}_2 & \cdots & g^{(1)}_q & g^{(2)}_1 & g^{(2)}_2 & \cdots & g^{(2)}_q & \cdots & g^{(n)}_1 & g^{(n)}_2 & \cdots & g^{(n)}_q \\
  \land & \land & & \land & \land & \land & & \land & & \land & \land & & \land \\
  v_{j,1} & v_{j,1} & \cdots & v_{j,1} & v_{j,2} & v_{j,2} & \dots & v_{j,2} & \cdots & v_{j,n} & v_{j,n} & \dots & v_{j,n} \\
  \land & \land & & \land & \land & \land & & \land & & \land & \land & & \land \\
  a_{l,1} & a_{l,2} & \cdots & a_{l,q} & a_{l,1} & a_{l,2} & \cdots & a_{l,q} & \cdots & a_{l,1} & a_{l,2} & \cdots & a_{l,q} \\
  };

  \node[left] at (m-1-1.east) {$\hat g\;=\;\phantom{g^{(1)}_1}$};
  \node[left] at (m-3-1.east) {$\hat v\;=\;\phantom{v_{j,1}}$};
  \node[left] at (m-5-1.east) {$\hat a\;=\;\phantom{a_{l,1}}$};

  \node[rotate=270,left] at (m-1-1.north) {$h_{1,j,1,l}=$};
  \node[rotate=270,left] at (m-1-2.north) {$h_{1,j,2,l}=$};
  \node[rotate=270,left] at (m-1-4.north) {$h_{1,j,q,l}=$};
  \node[rotate=270,left] at (m-1-5.north) {$h_{2,j,1,l}=$};
  \node[rotate=270,left] at (m-1-6.north) {$h_{2,j,2,l}=$};
  \node[rotate=270,left] at (m-1-8.north) {$h_{2,j,q,l}=$};
  \node[rotate=270,left] at (m-1-10.north) {$h_{n,j,1,l}=$};
  \node[rotate=270,left] at (m-1-11.north) {$h_{n,j,2,l}=$};
  \node[rotate=270,left] at (m-1-13.north) {$h_{n,j,q,l}=$};

  \coordinate (c) at (current bounding box.west);
\endtikzpicture
\eqno(\eqhmatrix)
$$
The bitvector $\hat g$ results from the concatenation of all row vectors from
the compact adjecency matrix of $G$.  The bitvector $\hat v$ is a mask of form
$0\dots 01\dots 10\dots 0$,
%more precisely $0^{(v(j)-1)p}1^p0^{(n-v(j))p}$,
where we have ones only for the entries $v_{j,v(j)}$.  Hence, $\hat v$ selects
the correct row vector $g^{(v(j))}$.  Finally, $\hat a = (a_{l,1}a_{l,2}\dots
a_{l,q})^n$ is a mask with $n$ copies of $a_{l,1}a_{l,2}\dots a_{l,q}$ which has
only one 1 at position $a_{l,a(l)}$.  We can see that $n-1$ of these copies are
discarded by $\hat v$ and only the $v(j)$-th copy remains.  From this copy it
selects the bit $g^{(v(l))}_{a(l)}$.  We collect all the bits $h_{i,j,k,l}$ in
(\eqhmatrix) in the set
$$H_{j,l} = \{h_{i,j,k,l}\mid1\le i\le n, 1\le k\le q\}. \eqno(\eqhjl) $$
With the previous considerations it is easy to see that there is at most one
variable in $H_{j,l}$ that is true in a satisfying assignment.  Moreover, there
exists one true variable in $H_{j,l}$ if and only if $g^{(v(j))}_{a(l)}=1$.
Now, we are ready to describe the main clauses that we add for all
$j\in\{1,\dots,m\}$ and $l\in\{1,\dots,r\}$.  If $p^{(j)}_l=1$ we add one large clause
$$ \bigvee_{h\in H_{j,l}} h \eqno(\eqttrue) $$
with $nq$ literals to ensure that also $g^{(v(j))}_{a(l)}=1$, and if we have
$p^{(j)}_l=0$ we add the $nq$ unit clauses
$$ \bigwedge_{h\in H_{j,l}} \bar h \eqno(\eqtfalse) $$
to ensure that also $g^{(v(j))}_{a(l)}=0$.  There is one last thing to do, since
we have ignored to add clauses for $h_{i,j,k,l}$.  Since the values for
$g^{(i)}_k$ are constant in (\eqhvar) we make a case distinction on them.  If
$g^{(i)}_k=0$ we just add the unit clause $\bar h_{i,j,k,l}$ and if
$g^{(i)}_k=1$, we add the three clauses
$$ (h_{i,j,k,l}\lor \bar v_{j,i} \lor \bar a_{l,k}) \land (\bar h_{i,j,k,l}\lor v_{j,i}) \land (\bar h_{i,j,k,l} \lor a_{l,k}). \eqno(\eqhclause) $$

\medskip\noindent{\bf Complexity of the formula.} \dots


% \smallskip\noindent{\bf Lemma 1.} \sl At most one variable in $H_{j,l}$ can be
% true in a satisfying assignment. \rm

% {\it Proof.} First, we assume that no negative unit clauses such as in (??) have
% been added.  According to (2) there is exactly one $\hat\imath$ such that
% $v_{j,\hat\imath}$ is true and therefore all $h_{i,j,k,l}$ for $i\neq\hat\imath$
% can be discarded and we get $H\supseteq \hat H=\{v_{j,\hat\imath}\land
% a_{l,k}\mid 1\le k\le p\}$.  With a similar argumentation there is also only one
% $\hat k$ such that $a_{l,k}$ is true.\slugonright

\medskip\noindent{\bf Further reading.}  Jacobo Tor\'an presents a SAT encoding
for graph isomorphism in [{\sl SAT\/ \bf 16} (2013), 52--66].

The subgraph isomorphism problem is known to be NP-complete for general graphs
[M.\ R.\ Garey and D.\ S.\ Johnson, {\sl Computers and Intractibility} (1979)].
Effecient implementations for special cases are discussed in [J.\ E.\ Hopcroft
and J.\ K.\ Wong, {\sl STOC\/ \bf 6} (1974), 172--184] and [E.\ M.\ Luks, {\sl
JCSS\/ \bf 25} (1982), 42--65].

[J.\ A.\ Roy, I.\ L.\ Markov, and V.\ Bertacco, {\sl IWLS\/ \bf 13} (2004)]

[C.\ Solnon, {\sl AI\/ \bf 174} (2010), 850--864]  [S.\ Zampelli and C.\ Solnon, {\sl Constraints\/ \bf 15} (2010), 327--353]

\medskip\noindent{\bf 2. Simulation graphs.}

\centerline{****}

\noindent{\bf Consideration of inverters.}

\centerline{****}

\noindent{\bf Symmetry breaking.}

\centerline{****}

\noindent{\bf Further improvements with preprocessing.}



\bye
<